//
//  LessonDetailViewController.swift
//  PLAN-IT
//
//  Created by KiwiTech on 13/08/19.
//  Copyright (c) 2019 KiwiTech. All rights reserved.
//
//  This file was generated by the Clean Swift Xcode Templates so
//  you can apply clean architecture to your iOS and Mac projects,
//  see http://clean-swift.com
//

import UIKit
import WebKit
import AVKit
import CoreData
import HCVimeoVideoExtractor
import FirebaseAnalytics
protocol LessonDetailDisplayLogic: class {
    func fetchLessonDetail(lesson: Lesson?, nextlessonId: Int?)
    func showAlertFor(text: String)
    func lessonCompleted()
}

class LessonDetailViewController: BaseViewController, LessonDetailDisplayLogic {
    @IBOutlet weak var completeBtnHeightConstraint: NSLayoutConstraint!
    @IBOutlet weak var collectionViewHeightConstraint: NSLayoutConstraint!
    @IBOutlet weak var heightConstraint: NSLayoutConstraint!
    @IBOutlet weak var collectionView: UICollectionView!
    @IBOutlet weak var coursenameLabel: UILabel!
    @IBOutlet weak var lessonNameLabel: UILabel!
    @IBOutlet weak var webView: WKWebView!
    @IBOutlet weak var completeLessonBtn: CustomiseButton!
    @IBOutlet weak var blurView: UIView!
    @IBOutlet var courseTilteViewLayoutCollection: [NSLayoutConstraint]!
    @IBOutlet weak var saveToLibraryBtn: UIButton!
    @IBOutlet weak var savedBtn: UIButton!
    var interactor: LessonDetailBusinessLogic?
    var router: (NSObjectProtocol & LessonDetailRoutingLogic & LessonDetailDataPassing)?
    var lessonObj = Lesson()
    var avPlayer: AVPlayer!
    var nextLessonId: Int?
    var overSpentPercent: Float?
    var lessonId: Int?
    var budgetCategory: BudgetCategory?
    var courseName: String?
    let avplayerController = AVPlayerViewController()
    var overSpentDescription: String?
    var isFromLibrary = false
    var lessonVideo: [Video]?
    var isVideoAdded = false
    var isLessonUpdated = false
    var player: YoutubePlayer = {
        return YoutubePlayer()
    }()
    var downloadSession: URLSession = {
        let config = URLSessionConfiguration.default
        config.timeoutIntervalForResource = TimeInterval(60)
        let session = URLSession(configuration: config)
        return session
    }()
    // MARK: Object lifecycle
    override init(nibName nibNameOrNil: String?, bundle nibBundleOrNil: Bundle?) {
        super.init(nibName: nibNameOrNil, bundle: nibBundleOrNil)
        setup()
    }
    required init?(coder aDecoder: NSCoder) {
        super.init(coder: aDecoder)
        setup()
    }
    // MARK: Setup
    private func setup() {
        let viewController = self
        let interactor = LessonDetailInteractor()
        let presenter = LessonDetailPresenter()
        let router = LessonDetailRouter()
        viewController.interactor = interactor
        viewController.router = router
        interactor.presenter = presenter
        presenter.viewController = viewController
        router.viewController = viewController
        router.dataStore = interactor
    }
    // MARK: View lifecycle
    override func viewDidLoad() {
        super.viewDidLoad()
        setBtnTitle()
        webView.scrollView.bounces = false
        webView.scrollView.showsHorizontalScrollIndicator = false
        webView.scrollView.showsVerticalScrollIndicator = false
        webView.scrollView.delegate = self
        if (overSpentDescription?.count ?? 0) > 0 {
            showOverspentdescription()
            for constraint in courseTilteViewLayoutCollection {
                constraint.constant = 0
            }
            self.lessonNameLabel.text = .budgetOverSpent
            self.lessonNameLabel.font = UIFont(font: (name: UIFont.FontName.karla, varient: UIFont.FontVarient.bold), size: 19) ?? UIFont.systemFont(ofSize: 19.0)
            self.collectionViewHeightConstraint.constant = 0
        } else {
            interactor?.fetchLessonDetail()
        }
        showLoader()
    }
    override func viewWillDisappear(_ animated: Bool) {
        removePlayer()
    }
    func showOverspentdescription() {
        isFromLibrary ? nil : retrieveData()
        self.completeLessonBtn.isHidden = true
        self.webView.navigationDelegate = self
        self.completeBtnHeightConstraint.constant = 0
        self.lessonNameLabel.text = ""
        self.coursenameLabel.text = ""
        let fontSetting = """
                              <head>\
                              <link rel="stylesheet" type="text/css" href="Font.css">\
                              </head>
                              """
        if let resourcePath = Bundle.main.path(forResource: "Font", ofType: "css") {
            let url = URL.init(fileURLWithPath: resourcePath)
            self.webView.loadHTMLString(fontSetting + "<meta name=\"viewport\" content=\"initial-scale=0.0\" />" + (overSpentDescription ?? ""), baseURL: url)
        }
    }
    func removePlayer() {
        self.avplayerController.player?.pause()
        self.avplayerController.view.removeFromSuperview()
        self.player.removePlayer()
    }
    @IBAction func backBtnAction(_ sender: Any) {
        self.navigationController?.popViewController(animated: true)
    }
    func fetchLessonDetail(lesson: Lesson?, nextlessonId nextLessonId: Int?) {
        if let data = lesson {
            lessonObj = data
            isFromLibrary ? nil : retrieveData()
            self.nextLessonId = nextLessonId
            self.completeLessonBtn.isHidden = isFromLibrary ? true : (lessonObj.isCompleted ?? false) ? true : false
            self.webView.navigationDelegate = self
            self.completeBtnHeightConstraint.constant = isFromLibrary ? 0 : (lessonObj.isCompleted ?? false) ? 0 : 100
            self.collectionViewHeightConstraint.constant = (lessonObj.lessonVideo?.count ?? 0) > 0 ? 262 : 0
            self.lessonNameLabel.text = lessonObj.title
            self.coursenameLabel.text = lessonObj.categoryName?.uppercased()
            let fontSetting = """
                              <head>\
                              <link rel="stylesheet" type="text/css" href="Font.css">\
                              </head>
                              """
            if let resourcePath = Bundle.main.path(forResource: "Font", ofType: "css") {
                let url = URL.init(fileURLWithPath: resourcePath)
                self.webView.loadHTMLString(fontSetting + "<meta name=\"viewport\" content=\"initial-scale=1.0\" />"  + (lessonObj.description ?? ""), baseURL: url)
            }
        }
    }
    func showAlertFor(text: String) {
        hideLoader()
        AppUtils.showBanner(with: text)
    }
    func lessonCompleted() {
        hideLoader()
        if let controller = AppUtils.viewController(with: LessonFeedbackViewController.identifier, in: .tabbar) as? LessonFeedbackViewController {
            controller.router?.dataStore?.lessonId = lessonObj.id ?? 0
            controller.router?.dataStore?.categoryName = lessonObj.categoryName
            self.navigationController?.pushViewController(controller, animated: true)
        }
    }
    @IBAction func completeLessonBtnAction(_ sender: Any) {
        showLoader()
        interactor?.completeLesson(request: LessonDetail.Request(lessonId: lessonObj.id ?? 0, nextLessonId: nextLessonId))
    }
    @IBAction func saveTolibraryBtnAction(_ sender: UIButton) {
        if !isFromLibrary {
            if let controller = AppUtils.viewController(with: OfflineReadPopup.identifier, in: .tabbar) as? OfflineReadPopup {
                controller.delegate = self
                controller.lessonObj = lessonObj
                controller.view.backgroundColor = UIColor.black.withAlphaComponent(0.8)
                controller.modalPresentationStyle = .overFullScreen
                self.navigationController?.present(controller, animated: false, completion: nil)
            }
        } else {
            if let controller = AppUtils.viewController(with: CustomPopUp.identifier, in: .main) as? CustomPopUp {
                controller.delegate = self
                controller.isFromLibrary = true
                controller.view.backgroundColor = UIColor.black.withAlphaComponent(0.8)
                controller.modalPresentationStyle = .overFullScreen
                self.navigationController?.present(controller, animated: false, completion: nil)
            }
        }
    }
    func setBtnTitle() {
        if isFromLibrary {
            self.savedBtn.isHidden = true
            let title = NSAttributedString(string: .removeFromLibrary, attributes: [
                NSAttributedString.Key.foregroundColor: UIColor(name: .errorColor),
                NSAttributedString.Key.font: UIFont(font: (name: UIFont.FontName.karla, varient: UIFont.FontVarient.bold), size: 11) ?? UIFont.systemFont(ofSize: 11.0),
                NSAttributedString.Key.underlineStyle: NSUnderlineStyle.single.rawValue, NSAttributedString.Key.underlineColor: UIColor(name: .errorColor)
                ])
            saveToLibraryBtn.setAttributedTitle(title, for: .normal)
        } else {
            self.savedBtn.isHidden = false
            let title = NSAttributedString(string: .saveToLibrary, attributes: [
                NSAttributedString.Key.foregroundColor: UIColor(name: .defaultColor),
                NSAttributedString.Key.font: UIFont(font: (name: UIFont.FontName.karla, varient: UIFont.FontVarient.bold), size: 11) ?? UIFont.systemFont(ofSize: 11.0),
                NSAttributedString.Key.underlineStyle: NSUnderlineStyle.single.rawValue, NSAttributedString.Key.underlineColor: UIColor(name: .defaultColor)
                ])
            saveToLibraryBtn.setAttributedTitle(title, for: .normal)
        }
    }
}
extension LessonDetailViewController: WKNavigationDelegate {
    func webView(_ webView: WKWebView, didFinish navigation: WKNavigation!) {
        DispatchQueue.main.asyncAfter(deadline: .now() + 0.05) {
            self.hideLoader()
            self.blurView.isHidden = true
            self.heightConstraint.constant = webView.scrollView.contentSize.height
        }
    }
    func webView(_ webView: WKWebView, decidePolicyFor navigationAction: WKNavigationAction, decisionHandler: @escaping (WKNavigationActionPolicy) -> Void) {
        if navigationAction.navigationType == WKNavigationType.linkActivated {
            if let controller = AppUtils.viewController(with: LoaderController.identifier) as? LoaderController {
                controller.detailUrl = navigationAction.request.url
                controller.hidesBottomBarWhenPushed = true
                self.navigationController?.present(controller, animated: true, completion: nil)
            }
            decisionHandler(.cancel)
            return
        }
        decisionHandler(.allow)
    }
}
extension LessonDetailViewController: OfflineReadDelegate {
    func dismissControllerToSaveData(isSaveToLibraryTapped: Bool, isVideoAdded: Bool) {
        if !(AppUtils.reachablityManager?.isReachable ?? true) {
            AppUtils.showBanner(with: .noInternet, type: .noInternet)
        } else {
            savedBtn.isHidden = isSaveToLibraryTapped ? false : true
            saveToLibraryBtn.isHidden = isSaveToLibraryTapped ? true : false
            self.isVideoAdded = isVideoAdded
            isLessonUpdated ? self.updateData() : self.saveData()
            Analytics.logEvent(.saveLibrary, parameters: [.userName: AppStateManager.shared.user?.fullName ?? "" as NSObject,
                                                              .userId: AppStateManager.shared.user?.id ?? 0 as NSObject, .lessonName: lessonObj.title ?? "" as NSObject, .lessonId: lessonObj.id ?? 0 as NSObject, .categoryId: budgetCategory?.categoryId ?? 0 as NSObject])
            if self.isVideoAdded {
                for index in 0..<(lessonObj.lessonVideo?.count ?? 0) {
                    let videoUrl = lessonObj.lessonVideo?[index]
                    VideoExtractor.main.getDownloadURL(for: videoUrl?.urlLink ?? "") {[weak self] (url, error) in
                        guard error == nil else {
                            let request = NSFetchRequest<DBLessonVideo>(entityName: "DBLessonVideo")
                            request.predicate = NSPredicate(format: "videoId == %d", videoUrl?.id ?? 0)
                            guard let result = try? context?.fetch(request), result.count > 0 else {
                                return
                            }
                            let objectUpdate = result[0]
                            objectUpdate.videoStatus = VideoDownloadStatus.error.rawValue
                            try? context!.save()
                            DispatchQueue.main.async {
                                AppUtils.showBanner(with: String(format: "Video %d format cannot be downloaded.", index + 1))
                                self?.collectionView.reloadData()
                            }
                            return
                        }
                        self?.downloadVideoLinkAndCreateAsset(Int64(videoUrl?.id ?? 0), (url?.absoluteString.count ?? 0 > 0 ? url?.absoluteString ?? "" : videoUrl?.video) ?? "") { (filePath, videoId, success) in
                            let request = NSFetchRequest<DBLessonVideo>(entityName: "DBLessonVideo")
                            request.predicate = NSPredicate(format: "videoId == %d", videoId)
                            guard let result = try? context?.fetch(request), result.count > 0 else {
                                return
                            }
                            let objectUpdate = result[0]
                            if success {
                                objectUpdate.video = videoUrl?.video?.count ?? 0 > 0 ? filePath?.absoluteString.replacingOccurrences(of: " ", with: "%20") : ""
                                objectUpdate.videoUrl = videoUrl?.urlLink?.count ?? 0 > 0 ? filePath?.absoluteString.replacingOccurrences(of: " ", with: "%20") : ""
                                objectUpdate.videoStatus = VideoDownloadStatus.downloaded.rawValue
                                let ext = ((filePath?.lastPathComponent ?? "").components(separatedBy: ".").first ?? "")
                                let fileName = ext + ".jpg"
                                if (videoUrl?.thumbnail?.count ?? 0) > 0 {
                                    self?.dowloadImageFromServer(url: URL(string: videoUrl?.thumbnail ?? "")!, completion: { (image) in
                                                                      if let thumbnail = image {
                                                                          objectUpdate.thumbnailUrl = try? AppUtils.saveImageInTemp(image: thumbnail, name: fileName).absoluteString
                                                                      }
                                                                  })
                                }
                            } else {
                                objectUpdate.videoStatus = VideoDownloadStatus.failure.rawValue
                            }
                            DispatchQueue.main.async {
                                self?.collectionView.reloadData()
                            }
                            do {
                                try context!.save()
                            } catch {
                                objectUpdate.videoStatus = VideoDownloadStatus.error.rawValue
                                try? context!.save()
                                AppUtils.showBanner(with: String(format: "Video %d format cannot be downloaded.", index + 1))
                                DispatchQueue.main.async {
                                    self?.collectionView.reloadData()
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
extension LessonDetailViewController: CustomPopUpDelegate {
    func dismissControllerToProceed() {
        self.removeData()
    }
}
